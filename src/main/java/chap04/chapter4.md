## 4장 : 설계 품질과 트레이드오프

### Step1 : 데이터 중심의 영화 예매 시스템
- 데이터 중심의 설계 관점은, 객체의 상태에 초점을 맞춘다. 객체의 상태는 구현에 속하며, 불안정하기 때문에 변하기 쉽다.
- 상태를 객체 분할의 중심축으로 잡으면, 구현에 관한 세부사항이 객체의 인터페이스에 스며들게 되어 캡슐화 원칙이 무너진다.
```java
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private List<DiscountCondition> discountConditions;

    private MovieType movieType;
    // enum의 type에 따라 어떤 discount를 적용할지 결정한다.
    private Money discountAmount;
    private double discountPercent;
```
- 위와 같이, 객체의 종류를 저장하는 인스턴스 변수 MovieType과, 이에 따라 배타적으로 사용될 인스턴스 변수(discountAmount, Percent)가 포함된다.
- 이러한 방식은 데이터 중심 설계 안에서 흔히 볼 수 있는 패턴이다.
- 여기서 나름 캡슐화를 지키고자 getter / setter를 선언한다. 하지만 이는 인터페이스를 외부에 그대로 노출시키는 행위가 된다.


#### 설계 트레이드오프
- 캡슐화 
    - 구현이란 나중에 변경될 가능성이 높은 어떤 것을 의미한다.
    - 인터페이스란 상대적으로 안정적인 부분을 의미한다.
    - 캡슐화는 불안정한 구현을 안정적인 인터페이스 뒤로 숨기는 것을 의미한다.
- 응집도
    - 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 의미한다. 객체 지향의 관점에서는 객체 또는 클래스에 얼마나 관련 높은 책임을 할당했는지 정도이다.
    - 응집도가 낮다는 것은, 어떤 요구사항 변경을 수용하기 위해 하나 이상의 클래스를 수정해야 한다는 것을 의미한다.
    - 즉, 요구사항에 대한 책임이 여러 클래스에 분배가 되어있다는 것을 의미하며, 이는 단일 책임 원칙을 위배한다.
- 결합도
    - 의존성의 정도를 나타내며, 다른 모듈에 대해 얼마나 많은 지식을 가지고 있는지 나타내는 척도이다.
    - 결합도가 높아도 상관없는 경우는, 일반적으로 변경될 확률이 매우 적은(String, ArrayList와 같은) 안정적인 모듈에 의존할때이다.
- 좋은 설계를 위해서는, 높은 응집도와 낮은 결합도를 추구해야 한다. 이들은 변경에 관련되어 있다.
  

### Step2 : 자율적인 객체를 향해
- 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있도록 하기 위해서이다.
- Step2도 어쨌든 데이터 중심 설계이므로, 여기에 초점을 맞추고 진행한다.
- 객체에 포함된 데이터를, 자기 자신 내부에서 다루도록 코드를 수정한다. 
- Step1에 비해서 조금 더 캡슐화는 진행되었다.

#### 하지만 여전히 부족하다.

1. 캡슐화 위반
- 여전히 메시지에 내부 상황을 노출한다. 메시지에 세부 파라미터를 노출시켜, 내부 구조를 외부에 노출시킨다.
- 따라서 내부 구조가 변경되어 메시지가 변경되면 -> 호출하는 대상의 메시지를 변경해야 한다. 캡슐화를 만족시키지 않는다.
- Movie도 마찬가지로 여러 계산 정책에 대한 메시지를 외부로 노출한다 -> 새로운 할인 정책 추가될 경우, 메시지를 추가해야 한다.

2. 높은 결합도
- DiscountCondition이 추가되면, Movie에서 condition 체크하는 부분이 수정되어야 한다.
- 즉, DiscountConditon의 구현 변경사항에도, Movie를 변경시킨다는 것은 결합도가 높다는 것을 의미한다.
- 이는 캡슐화를 지키지 않아 생긴 문제이다.

3. 낮은 응집도
- DiscountCondition에서 필요한 정보가 변경되면, Movie의 isDiscountable 파라미터가 변경되어야 한다.
- 이는 Movie를 사용하는 Screening에서 isDiscountable 메시지를 사용하므로, 이 부분도 변경해야 한다.
- 한 객체의 변경이 2개의 객체 변경에 영향을 미쳤다. 이는 낮은 응집도가 원인이다.
- 이 역시 캡슐화 위반으로 발생한 문제이다.


#### 데이터 중심 설계의 문제점
- 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.
- 객체의 인터페이스에 구현이 노출되어 있기 때문에, 협력이 구현 세부사항에 종속되어 있다.
- 따라서 객체의 내부 구현이 변경되었을때 협력하는 객체 모두가 영향을 받게 된다!