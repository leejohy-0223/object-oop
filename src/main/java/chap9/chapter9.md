## 9장 : 유연한 설계
- 8장에서 배운 유연하고 재사용 가능한 설계에 대해, 원칙의 관점에서 정리해보자.

<br>

### 1. 개방-폐쇄 원칙(Open-Closed Principle, OCP)
- 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려였어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- 여기에서 키워드는 '확장'과 '수정'이다.
   - 확장 : 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다.
   - 수정 : 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 어떻게 수정 없이 새로운 동작을 추가할 수 있을까?

<br>

#### 컴파일 타임 의존성을 고정시키고 런타임 의존성을 변경하라
- OCP는 결국 런타임 의존성과 컴파일타임 의존성에 관한 이야기이다.
    - 런타임 : 실행 시에 협력에 참여하는 객체들 사이의 관계
    - 컴파일타임 : 코드에서 드러나는 클래스 사이의 관계
    
- 앞서 설계한 DiscountPolicy 구조는 이를 반영한다.
    - Movie(클라이언트)는 여전히 DiscountPolicy에만 의존한다. 따라서 컴파일 타임 의존성은 변하지 않는다.
    - 하지만 런타임에 Movie 인스턴스는 DiscountPolicy를 구현한 구체 클래스에 의존하게 된다. 따라서 런타임 의존성은 변하게 된다.
    
- 의존성 관점에서 OCP를 따르는 설계란, 컴파일 타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조이다.

<br>

#### 추상화가 핵심이다.
- OCP의 핵심은 **추상화에 의존**하는 것이다.
    - 추상화 : 핵심적인 부분을 남기고, 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다. 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.
    - 의존 : 단순히 어떤 개념을 추상화했다고 수정에 대해 닫혀있는 설계가 되는 것은 아니다. 폐쇄를 가능케 하는 것은 의존성의 방향이다. 수정의 영향을 최소화하기 위해서는 모든 요소가 **추상화**에 의존해야 한다.
    
- 8장에서 배운 것처럼, 명시적 의존성과 의존성 해결 방법을 통해 컴파일 타임 의존성 -> 런타임 의존성으로 대체함으로써 실행 시에 객체의 행동을 확장할 수 있다.
- 변경에 의한 파급 효과를 최대한 피하기 위해서는, 변하는 것과 변하지 않는 것이 무엇인지를 이해하고, 이를 추상화의 목적으로 삼아야 한다.

<br>

### 2. 생성, 사용 분리
- 결합도가 높아질수록 OCP를 따르는 구조를 설계하기가 어려워진다. 알아야 하는 지식이 많으면 결합도가 높아지게 된다.
- 객체 생성을 피할수는 없다. 문제는 부적절한 곳에서 객체를 생성하는 것이다.
- 동일한 클래스 안에서 **객체생성**과 **사용**이라는 두 가지 이질적인 목적을 가진 코드가 공존하면 문제가 될 것이다.
- 사용으로부터 생성을 분리하는 가장 보편적 방법은 객체 생성할 책임을 클라이언트로 옮기는 것이다.
- (Movie를 사용하는)클라이언트는 (할인 정책이라는 구체적인)생성의 책임을 맡게 되고, 이를 전달받은 객체(Movie)는 추상화 된 객체(DiscountPolicy)를 사용할 책임만을 가지게 된다.

<br>

#### FACTORY 추가하기
- 앞서 클라이언트도 Movie 객체에 대해 생성과 사용(getFee)의 책임을 동시에 갖는 코드이다.
- 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가할 수 있다. 
- 이처럼 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 **Factory**라고 한다.

#### 객체 생성에 특화된 Factory
```java
import java.time.Duration;

import chap2.movie.step1.pricing.AmountDiscountPolicy;

public class Factory {
	public Movie createAvatarMovie() {
		return new Movie("아바타",
			Duration.ofMinutes(120),
			Money.wons(10000),
			new AmountDiscountPolicy(...));
	}
}
```

#### Factory로부터 생성된 Movie를 반환받는 Client
```java
public class Client {
	private Factory factory;

	public Client(Factory factory) {
		this.factory = factory;
	}
	
	public Money getAvaterFee() {
		Movie avatar = factory.createAvatarMovie();
		return avatar.getFee();
    }
}
```
- 이제 클라이언트는 Movie의 인스턴스에 대한 생성 책임은 없다. 오로지 사용 책임만 가지게 된다.
- 앞서 책임 할당의 기본이 되는 원칙은 책임을 수행하는 데 필요한 정보를 많이 알고 있는 **Information expert**에게 책임을 할당하는 것이다. 도메인 모델은 이를 위해 참조할 수 있는 일차적인 재료이다.
- 어떤 책임을 할당하고 싶다면 제일 먼저 도메인 모델 안의 개념에서 적절한 후보를 찾아야 했다.
- 하지만 위의 Factory는 도메인 모델에 속하지 않는다. 이는 순수하게 기술적인 결정이다.
- 모든 책임을 도메인 객체에 할당하면 낮은 응집도, 높은 결합도, 재사용성 저하와 같은 문제에 봉착하게 될 가능성이 높아진다.
- 이 경우 설계자가 편의를 위해 임의로 만들어낸 가공의 객체에개 책임을 할당하여 문제를 해결할 수 있다. 
- 이와 같은 도메인과 무관한 인공적인 객체를 **Pure Fabrication**이라고 한다.
- 대부분의 디자인 패턴은 **Pure Fabrication**을 포함한다.

<br>

### 3. 의존성 주입
- 생성과 사용을 분리하면 Movie에는 오로지 인스턴스를 사용하는 책임만 남게 된다. 따라서 외부의 다른 객체가 Movie에게 생성된 인스턴스를 전달해야 한다.
- 외부의 독립적인 객체가 인스턴스를 생성 후 이를 전달해서 의존성을 해결하는 방법을 **의존성 주입** 이라고 한다. 
- 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하기 때문이다.
- 방법은 다음 3가지가 있다.
    - 생성자 주입 : 객체를 생성하는 시점에 생성자를 통한 의존성 해결
    - setter 주입 : 객체 생성 후 setter 메서드를 통한 의존성 해결
         - 올바로 객체가 생성되기 위해 어떤 의존성이 필수인지 명시적으로 푷련할 수 없다. 
         - setter는 객체가 생성된 후에 호출되어야 한다. 만약 호출되지 않았다면 런타임에 객체의 정상동작을 보장할 수 없다.
         - 생성자 주입의 경우, 주입을 강제하기 때문에 주입되지 않는다면 컴파일 시점에 에러가 발생한다. 
    - 메서드 주입 : 메서드 실행 시 인자를 이용한 의존성 해결 
    
<br>

#### 숨겨진 의존성은 나쁘다
- 위의 3가지 이외에 Service Locator 패턴이 있다. 
- 이는 외부에서 객체에게 의존성을 전달하는 의존성 주입과는 달리, 객체가 직접 Service Locator에게 의존성을 해결해줄 것을 요청한다.
    1. ServiceLocator.provide(new AmountDiscountPolicy ..)를 통해 인스턴스를 먼저 등록한다.
    2. 객체(여기에서는 Movie)의 생성자 내에서, DiscountPolicy를 ServiceLocator로부터 전달받는다.(Movie의 생성자에는 DiscountPolicy가 드러나지 않는다.)
    
- 가장 큰 단점은, 의존성을 감춘다는 것이다. Movie의 생성자 어디에도 이 의존성에 대한 정보가 표시되어있지 않다. 
- 의존성을 구현 내부로 감출 경우, 관련 문제가 컴파일 타임이 아닌 런타임에 가서야 발견된다.
- 이러한 코드는 단위 테스트 작성도 어렵다. ServiceLocator는 내부적으로 정적 변수를 사용해 객체를 관리하기 때문에 모든 단위테스트가 ServiceLocator의 상태를 공유하게 될 것이다.  
- 변경되는 내용을 private으로 숨겼다고 캡슐화가 지켜지는 것은 아니다.  
핵심은 의존성을 이해하기 위해 코드의 내부 구현을 이해할 것을 강조한다는 것이다!
  
- 어쩔 수 없이 사용하는 경우는 다음과 같다.
    - 의존성 주입을 지원하는 프레임워크를 사용하지 못하는 경우.
    - 깊은 호출 계층에 걸쳐 파라미터로 동일한 객체를 계속해서 전달해야 하는 경우.
    
<br>

### 4. 의존성 역전 원칙
- Movie는 '가격 계산'이라는 높은 수준의 개념을 구현한다.(상위 수준)
- AmountDiscountPolicy라는 '금액 할인'이라는 더 낮은 수준의 개념을 구현한다.(하위 수준)
- 상위 수준이 하위 수준에 의존하게 될 경우, 하위 수준의 변경에 의해 상위 수준이 영향을 받게 될 것이다.  
  하위 수준의 AmountPolicy를 PercentPolicy로 변경한다고 해서, 상위 수준의 Movie가 영향을 받으면 안된다. 상위의 Movie 변경이 하위에 영향을 받아야 한다.
  
- 즉 상위 수준 클래스는 어떤 식으로든 하위 수준 클래스에 의존해서는 안된다. 그 역은 성립한다.  
  상위 클래스의 구현(추상) 변경은 곧 요구 사항 등의 변경이다. 이 변경으로 하위 클래스에 대한 구체화가 변경되는 것은 옳다.
- 이 경우에도 **추상화**로 해결할 수 있다. 상위, 하위 수준 모드 추상화에 의존하도록 수정하면 된다.
    - 하위 클래스 변경에도 상위 클래스는 영향받지 않는다.
    - 상위 수준을 재사용할 때 하위 수준의 클래스에 얽매이지 않고도 다양한 컨텍스트에서 재사용이 가능하다.
    
- 구체 클래스는 의존성의 시작점이어야 한다. 목적지가 되어서는 안된다.
- 이를 의존성 역전 원칙이라고 한다. 전통적인 절차형 프로그래밍과는 반대 방향으로 나아가기 때문이다.
    - 전통적인 방식 : 상위 수준의 모듈이 하위 수준의 모듈에 의존한다. 정책이 구체적인 것에 의존하는 경향이 있다.
    
<br>

#### 의존성 역전 원칙과 패키지
- 역전은 의존성의 방향 뿐 아니라 인터페이스의 소유권에도 적용된다.  
  Movie 패키지와, DiscountPolicy - AmountDiscount, PercentDisCount 패키지 두 개가 따로 있다고 가정하자.
- Movie를 정상적으로 컴파일하기 위해서는 DiscountPolicy가 필요하다. 코드의 컴파일이 성공하기 위해 함께 존재해야하는 코드를 정의하는 것이 컴파일 타임 의존성이다.
- 문제는 DiscountPolicy 패키지에 Amount, Percent 클래스도 함께 존재한다는 것이다. 
  이는 DiscountPolicy(추상)에 의존하기 위해 반드시 패키지에 포함된 Amount, Percent(구체) 클래스도 함께 존재해야 한다는 것이다.
  
- 만약 DiscountPolicy가 포함된 패키지 안의 어떤 클래스가 수정되더라도 패키지 전체가 재배포되어야 한다. 이로 인해 이 패키지에 의존하는 Movie 클래스 패키지도 재컴파일 되어야 한다.
- 따라서 불필요한 클래스들을 같은 패키지에 두는 것은 전체적인 빌드 시간을 상승시킨다.
- Movie 재사용을 위해 필요한 것이 DiscountPolicy라면, 이를 Movie와 같은 패키지로 모으고 Amount, Percent는 별도의 패키지로 위치시켜 의존성 문제를 해결할 수 있다.
- 이를 Seperated Interface 패턴이라고 한다.
- 따라서 의존성 역전 원칙에 따라 상위 수준의 협력 흐름을 재사용하기 위해서는 추상화가 제공하는 인터페이스(DiscountPolicy)의 소유권 역시 역전시켜야 한다.
- 전통적인 패러다임에서 인터페이스가 하위 수준 모듈에 속했다면, 객체 지향 패러다임에서는 인터페이스가 상위 수준 모듈에 속한다.

<br>

### 5. 유연성에 대한 조언

#### 유연성 설계는 유연성이 필요할 때만 옳다
- 유연한 설계의 이면에는 복잡한 설계라는 의미가 숨어있다. 
- 객체지향 코드에서 클래스의 구조는 발생 가능한 모든 객체 구조를 담는 틀일 뿐이다.  
  특정 시점의 구조를 파악하려면 클래스를 사용하는 클라이언트 코드 내에서 객체를 생성하거나 변경하는 부분을 직접 살펴보는 것 뿐이다.
  
- 설계가 유연할 수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다.
- 따라서 불필요한 유연성은 불필요한 복잡성을 낳는다. 단순하고 명확한 해법이 만족스럽다면, 유연성을 제거하라.

<br>

#### 결론은.. 또 협력과 책임이 중요하다!
- 설계를 유연하게 만들기 위해서는 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는지가 중요하다.
- Movie가 다양한 할인 정책과 협력할 수 있는 이유는, 모든 할인 정책이 Movie가 전송하는 calculateDiscountAmount 메시지를 이해할 수 있기 때문이다.
- 실수 중 하나는 객체의 역할과 책임이 자리 잡기 전에 성급하게 객체의 **생성**에 집중하는 것이다.
- 객체를 생성할 책임을 담당하는 객체나 생성 메커니즘을 결정하는 시점은 책임 할당의 마지막 단계로 미루자.
- 즉 비즈니스 로직을 처리하기 위한 책임을 할당하고 협력의 균형을 맞추는 것이, 생성에 관한 책임을 할당하는 것보다 더 우선이다. 
- 의존성을 관리해야 하는 이유는 역할, 책임, 협력의 관점에서 설계가 유연하고 재사용 가능해야 하기 때문이다. 따라서 역할, 책임, 협력에 먼저 집중하자.


    

