## 8장 : 의존성 관리하기
- 협력은 필수이지만 과도한 협력은 설계를 곤경에 빠트릴 수 있다.
- 협력은 객체가 다른 객체에 대해 알 것을 강요한다. 이러한 지식이 객체 사이에 의존성을 낳는다.
- 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술이다.

<br>

### 1. 의존성 이해하기
- 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 갖는다.
    - 실행 시점(런타임) : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
    - 구현 시점(컴파일) : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.
    
- 의존성은 방향성을 가지며, 항상 단방향이다. 
- 의존성은 인터페이스 상속, 추상 클래스 상속, 인스턴스 변수, 메서드 인자 또는 지역 변수의 공통 특성이다.

- 의존성은 전이될 수 있다. 
    - 직접 의존성 : 한 요소가 다른 요소에 직접 영향(코드에 명시적으로 드러남)
    - 간접 의존성 : 직접 드러나지는 않지만, 의존성 전이에 의해 전파되는 경우
    
#### 런타임 의존성
- 애플리케이션이 실행되는 시점을 가리킨다. 
- 런타임의 주인공은 객체이다. 따라서 객체 사이의 의존성을 다룬다.
- 실행시의 인스턴스에 해당한다.

#### 컴파일 의존성
- 컴파일이 진행되는 시점, 또는 코드의 작성 시점이라고 볼 수 있다.
- 컴파일 타임의 주인공은 클래스이다. 따라서 클래스 사이의 의존성을 다룬다.
- 추상 클래스나 인터페이스를 사용하는 건 컴파일 타임 의존성이다.

- 유연한 설계는 컴파일 의존성을 구체적인 런타임 의존성으로 대체하는 것이다.
- 컴파일 타임 구조와 런타임 구조 사이의 거리가 멀수록 설계가 유연해지고 재사용이 가능해진다.

#### 컨텍스트 독립성
- 클래스가 특정 문맥(context)에 강하게 결합되면, 당연히 다른 문맥에서 사용하기 어려워진다.
- 클래스가 사용될 특정 문맥에 대해 최소한의 가정으로만 이루어진다면 재사용이 수월해진다.
- 설계의 유연성을 위해 가능한 자신이 실행될 컨텍스트에 대한 구체적 정보를 최대한 적게 알아야 한다.


#### 의존성 해결하기
- 객체를 생성하는 시점에 생성자를 통해 의존성을 해결한다.
- 객체 생성 후 setter를 통해 의존성을 해결한다.
- 메서드 실행 시 인자를 통해 의존성을 해결한다.

<br>

### 2. 유연한 설계

#### 의존성과 결합도
- 의존성은 객체 사이의 협력을 가능하게 하기 때문에 존재 자체는 바람직하다.
- 하지만 문제는 의존성의 정도이다. 바람직한 의존성은 재사용성과 관련이 깊다.

- 의존성 : 두 요소 사이의 관계 유무를 설명한다.
- 결합도 : 두 요소사이에 의존성의 정도를 상대적으로 표현한다.

#### 지식이 결합을 낳는다.
- 결합도의 정도는 한 요소가 다른 의존하는 요소에 대해 알고있는 정보의 양으로 결정된다.
- 더 많이 알고 있다는 것은 더 구체화되었다는 것을 의마하며, 더 적은 컨텍스트에서만 사용할 수 있다는 것을 의미한다.


#### 추상화에 의존하라
- 구체 클래스 의존성 -> 추상 클래스 의존성 -> 인터페이스 의존성 순으로 결합이 느슨해진다.
- 의존하는 대상이 더 추상적일 수록, 결합도는 낮아진다.


#### 명시적인 의존성
- 생성자나 setter로 주입받는 경우, 명시적으로 퍼블릭 인터페이스에 노출시키는 것이다.
- 이를 통해 외부에서 어떤 객체를 주입해야 할지 알 수 있게 된다.
- 의존성을 구현 내부에 숨겨놓으면 안된다. 이를 통해 컴파일 타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.


#### new는 해롭다.
- new 연산자를 사용하기 위해 구체 클래스의 이름을 직접 기술해야 한다. 이를 통해 결합도가 높아진다.
- new 연산자는 생성하려는 구체 클래스 뿐 아니라, 어떤 인자를 이용해서 클래스의 생성자를 호출해야하는지도 알아야 한다. 따라서 클라이언트가 알아야 할
지식의 양이 늘어나기 때문에 결합도가 높아진다.
- 외부에서 이미 생성된 인스턴스를 주입받자.
- 주로 협력하는 기본 객체를 설정하고 싶을 때에는 가끔 사용해도 무방하다. 


#### 조합 가능한 행동
- 유연하고 재사용 가능한 설계는 객체가 어떻게 하는지를 장황하게 나열하지 않고도 객체들의 조합을 통해 무엇을 하는지를 표현하는 클래스로 구성된다.
- 작은 객체들의 행동을 조합함으로써 새로운 행동을 이끌어내는게 유연한 설계이다.
- 시스템에 포함된 객체의 구성을 변경해(절차적인 코드를 작성하기보다는 인스턴스 추가나 제거 또는 조합을 달리해서) 시스템의 작동 방식을 바꿀 수 있다.
