## 10장 : 상속과 코드 재사용
- 객체 지향의 장점 중 하는 코드 재사용 용이하다는 것이다. 
- 재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.
- 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법은 합성이라고 한다.(11장)

<br>

### 1. 상속과 중복 코드

---

#### DRY(Don't Repeat Yourself), 반복하지 마라
- 중복 코드는 변경을 방해한다. 변경이 발생할 경우, 중복 코드 집합을 하나하나 찾아서 모두 변경해야 한다.

<br>

#### 중복과 변경 (Step 1)
- 일반 폰과 저녁요금 할인 폰 두 종류가 있다고 가정한다.
- 이 두가지 폰은 대부분 기능이 같지만, 저녁요금 할인 폰의 경우, 특정 시간 이후에는 nightAmount로 계산하는 프로퍼티가 추가로 존재한다.
- 계산은 각각 'calculateFee'라는 메서드에서 각자의 로직으로 요금을 계산한다.  
- 중복되는 내용이 많음에도, 각자 분리해서 관리 중이다.

<br>

#### 중복 코드 수정하기 (Step 2)
- Step 1에서, 추가로 부과되는 세율이라는 항목이 추가된다고 가정한다.
- 각 일반, 저녁할인 폰 클래스에 taxRate라는 프로퍼티를 추가하고, calculateFee를 수정해준다.
- taxRate의 추가와 계산하는 부분의 실질적인 역할은 동일하나, 번거롭게 각각 추가해줘야 한다.

<br>

#### 타입 코드 사용하기 (Step 3)
- 중복을 제거하고자, 두 가지 폰을 Phone 클래스로 묶었다.
- enum Type을 통해 각 두가지 폰을 구분하고, 각각 생성자를 다르게 두었다.
- 하지만 이 클래스는 낮은 응집도를 가지고 있다.
    - Enum type의 추가 또는 변경 시 이 클래스를 수정해야 한다.
    - 일반 요금 관련 변경 시 이 클래스를 수정해야 한다.
    - 저녁 요금 관련 변경 시 이 클래스를 수정해야 한다.
    - 이처럼 다양한 이유로 수정점이 존재한다.
    
<br>

#### 상속을 이용하여 중복 코드 제거하기 (Step 4)
- 기존 Step1에서의 Phone을, NightlyDiscountPhone(저녁 할인 폰)가 상속 받도록 구현한다.
- 이를 통해 Phone 클래스의 코드 대부분을 재사용할 수 있다.
- 하지만 NightlyDiscountPhone에서는, 일반 Phone과 다르게 저녁 요금이 할인된다고 했다.
- 따라서 일반 폰의 요금에서 할인 요금 정도를 추가로 계산해서 빼야하는 복잡한 로직이 필요해진다.
- 매우 직관적이지 않고, 만든 개발자만 이해할 수 있을 것이다.
- 이와 같이 상속은 결합도를 높인다. 부모 클래스의 의도(그냥 일반적인 요금 계산)를 정확히 파악해야 하며, 여기에 부가적으로 자식 클래스의 구현을 덧붙인다.

<br>

#### 강하게 결합된 Phone과 NightlyDiscountPhone (Step 5)
- Step 4에 다시 세금 정책을 추가한다고 가정하자.
- NightlyDiscountPhone에서 super 생성자를 호출할 때, 추가 변수를 전달해줘야 한다.  
- 또한 Phone에서의 세금 계산 + NightlyDiscountPhone에서 추가 세금 계산 및 처리가 필요해진다.
- 자식 클래스에서 super 참조를 통해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. 이를 제거할 수 있는 방법을 찾아야 한다.

<br>

### 2. 취약한 기반 클래스 문제
- 부모 클래스의 변경에 의해 자식 클래스가 영향을 받는 현상
- 상속 관계를 추가할 수록 전체 시스템의 결합도가 높아진다.
- 상속은 기능 확장에는 용이하지만, 높은 결합도로 인해 부모 클래스를 개선하는 것은 어렵게 만든다.

<br>

#### 불필요한 인터페이스 상속 예시
- Vector(super) - Stack(sub) : stack의 의도는 LIFO(Last In First Out)이다. 하지만 Vector로부터 상속된 add(index, element)로 인해 특정 인덱스에도 접근이 가능해진다.
- HashTable(super) - Properties(sub) : Properties의 의도는 key, value를 오직 String으로만 가지는 것이다. 하지만 HashTable 인터페이스에 포함된 put을 통해 String 타입 이외의 값도 저장할 수 있다.
- 이처럼 상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

<br>

#### 메서드 오버라이딩의 오작용 문제
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩 할 경우, 부모 클래스의 메서드에서 자신의 메서드를 호출할 때 자식의 메서드가 결합(즉 호출)될 수 있다.
    - 만약 A라는 메서드 안에서 B 메서드를 호출한다고 가정하자.
    - 자식에서 B를 오버라이딩 했다.
    - 자식 인스턴스에서 (오버라이딩 하지 않은) A를 호출한다. 이 때 A에서드에서는 방금 오버라이딩 된 B를 호출하게 된다.
    - 따라서 예상치 못한 결과가 발생할 수 있게 된다.
  
<br>

#### 부모 클래스와 자식 클래스의 동시 수정 문제
- 앞의 두 사례처럼 자식 클래스가 부모 클래스의 불필요한 인터페이스를 상속받지 않거나, 메서드를 오버라이딩 하지 않았음에도 부모 클래스의 수정은 자식에게 영향이 가게 된다.
- 결합도란 다른 대상에 대해 알고 있는 지식의 양이다. 상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에, 자식 클래스가 부모 클래스의 내부에 대해 속속들이 알도록 강요하게 된다.
  
- 슈퍼 클래스의 작성자가 확장될 목적으로 (즉 오로지 확장의 목적으로 설계했다면 슈퍼 클래스의 변경은 더 이상 없을 것이다) 해당 클래스를 설계한게 아니라면, 서브 클래스는 슈퍼 클래스와 보조를 맞춰 진화해야 한다. 즉 수정이 불가피하다는 것이다.
  
<br>

### Phone 다시 살펴보기
- 문제 해결의 열쇠는 바로 추상화이다.

<br>

#### 추상화에 의존하자
- 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출해라.
- 자식 클래스의 코드를 상위로 올린다. 재사용, 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

<br>

#### 차이를 메서드로 추출하고, 중복 코드를 부모 클래스로 올려라 (step 6)
- calculateFee라는 메서드에서, Phone, NightlyDiscountPhone 사이에 차이가 있는 부분만 메서드로(동일한 이름) 뽑아낸다.
```java
public Money calculateFee() {
    Money result = Money.ZERO;

    for (Call call : calls) {
            // 심야 요금제와 따로 계산이 필요해진다.
            result = result.plus(calculateCallFee(call)); // 부모에서도 자신의 추상 메서드를 호출 = 추상화에 의존하게 된다.
    }

    return result;
}
```
- 위와 같이, calculateCallFee 부분을 제외하고는 메서드가 동일하다.
- 따라서 위의 모양을 부모 클래스인 AbstractPhone으로 올린다.
- 이 때 부모 클래스에는 calculateCallFee 메서드가 없으므로, 이는 추상 메서드로 시그니처를 이동시킨다.
- 이를 상속받는 Phone, NightlyDiscountPhone에서는 각자의 방법으로 이를 구현하고 있으므로, 해결된다.
- 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩터링 하자. 차이점을 메서드로 추출하고, 공통 부분은 부모로 올린다.

<br>

#### 의도를 드러내는 이름 선택 및 변경사항 추가 (step 7)
- 기존 AbstractPhone -> Phone으로 수정하고, 구체화 클래스는 그 의도에 맞게 수정한다.
- 다시 세금 계산 항목이 추가된다고 가정하자. 
- 공통 속성이므로, 부모 클래스에 taxRate 변수를 추가하고, calculateFee를 다음과 같이 수정한다.
```java
public Money calculateFee() {
    Money result = Money.ZERO;

    for (Call call : calls) {
            // 심야 요금제와 따로 계산이 필요해진다.
            result = result.plus(calculateCallFee(call)); // 부모에서도 자신의 추상 메서드를 호출 = 추상화에 의존하게 된다.
    }

    return result.plus(result.times(taxRate));
}
```
- 다 끝난걸까? 아니다. 이를 구현한 자식 클래스에서 이에 맞게 super 생성자에 taxRate를 받아서 올려줘야 한다.
- 클래스의 상속은 자식 클래스가 부모 클래스가 구현한 행동 뿐 아니라 인스턴스 변수에도 결합하게 만든다.
- 객체의 행동만 변경된다면 문제가 없지만, 인스턴스 변수의 경우 자식 클래스의 초기화 로직에 영향을 받게 된다.
- 그래도 이전 코드에 비해서 많이 유연해졌음을 알 수 있다.

<br>

### 정리
- 상속은 강력한 도구이지만, 잘못 사용한 경우에 돌아오는 피해 역시 매우 크다.
- 상속의 오남용은 애플리케이션을 이해하고 확장하는 것을 어렵게 만든다.
- 상속은 재사용과 관련된 대부분의 경우에 우아한 해결 방법이 아니다. 다음 chapter의 **합성**을 알아보자.