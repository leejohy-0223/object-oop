## 2장 : 객체지향 프로그래밍

### 협력, 객체, 클래스
- 진정한 객체 지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때만 얻을 수 있다.
   1. 어떤 클래스가 필요한지 고민 전에 어떤 객체들이 필요한지 고민하라. 
       - 클래스는 공통적인 상태와 행동을 공유하는 객체를 추상화한 것이다.
       - 따라서 클래스 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지 먼저 결정해야 한다.
   2. 객체는 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.
       - 객체의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체를 타입으로 분류하고, 이 타입을 기반으로 클래스를 구현하라.
       - 훌륭한 협력이 훌륭한 객체를 낳고, 훌륭한 객체가 훌륭한 클래스를 낳는다.
    
    
- 도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
  

- 경계의 명확성이 객체의 자율성을 보장한다. 따라서 클래스의 외부와 내부를 구분해야 한다.
  

- 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것
  

- 인터페이스와 구현의 분리 원칙  
   - public interface : 외부에서 접근 가능한 부분
   - implementation : 내부에서먄 접근 가능한 부분

       
- 앞서 금액을 구현하기 위해 Long 대신 Money 객체를 만들어서 표현했다. 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 점이다.
해당 개념이 비록 하나의 인스턴스 변수만 포함하더라도, 개념을 명시적으로 표현하는 것이 좋다.
  

- 메시지와 메서드를 구분해서 이해하자.
   - 메시지 : 객체 간 상호작용하기 위한 방법. 즉 외부에서는 메시지를 받는 객체가 메시지를 처리할 수 있다고 믿고 보낸다. 
   - 메서드 : 수신된 메시지를 처리하기 위한 자신(객체)만의 방법이다. 메시지를 수신한 객체는 스스로 적절한 메서드를 선택한다.

    
- 템플릿 메서드 패턴 : 부모 클래스에 기본적인 흐름을 구현하고, 중간에 필요한 처리는 자식 클래스에게 위임하는 디자인 패턴(hook 등으로 구현 메서드 실행 후에 동작하는 메서드도 설정 가능하다.)


- 상속과 인터페이스
   - 상속 : 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있다. 이를 이용해서 동일한 인터페이스를 공유하는 클래스를 하나의 타입 계층으로 묶을 수 있다.
   - 인터페이스 : 객체가 이해할 수 있는 메시지의 목록을 정의하는 것

    
- 업캐스팅
    - 자식 클래스가 부모 클래스를 대신하는 것(부모 클래스를 일반적으로 위에 위치시키며, 위로 캐스팅 되었다고 이해하자.)  
    즉, 부모 타입에 자식 객체가 할당된것을 의미한다. 
      

- 다형성 : 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다. 메시지(컴파일 타임)와 메서드(실행 타임)를 실행 시점에 바인딩하는 것을 지연 바인딩 또는 동적 바인딩이라고 한다.


- 구현 상속(implementation inheritance == subclassing) : 순수하게 코드를 재사용하기 위한 목적으로 상속하는 것


- 인터페이스 상속(interface inheritance == subtyping) : 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 이용하는 것! 이처럼 상속은 인터페이스 상속을 위해 사용해야 한다.


- 추상 클래스와 인터페이스의 트레이드 오프
   - 추상 클래스 : 확장의 개념. 부모 클래스의 기능 + 자식 클래스의 기능. 구현의 일부를 자식 클래스가 결정하도록 결정권을 위임한다.
   - 인터페이스 : 제약의 개념. 또한 결합력을 느슨하게 할 수 있다. 구현(내부에서만 접근 가능한 코드)을 공유할 필요 없다면 이를 이용한다. 구현의 전체를 자식에서 결정하도록 한다.
    

- 코드 재사용
   - 합성(composition) : 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용. 즉, 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 것.
   - 상속 : 재사용하기 위한 방법이지만, 캡슐화를 위반하고 설계의 유연성을 막는다.
       - 캡슐화 위반 : 부모 클래스의 구현이 자식 클래스에게 노출이 된다. 캡슐화의 약화는 자식과 부모의 결합도를 높이게 된다.   
   - 상속과 합성을 함께 사용해야 한다. 